# 前端监控 SDK 概要设计文档

## 1. 系统架构

### 1.1 总体架构

前端监控 SDK 采用模块化、可插拔的设计架构，主要包含以下几个核心部分：

```
┌─────────────────────────────────────────────────────────┐
│                  前端监控SDK                            │
├───────────┬───────────┬───────────┬───────────┬─────────┤
│  核心模块  │  数据采集  │  数据处理  │  数据上报  │ 公共工具 │
└───────────┴───────────┴───────────┴───────────┴─────────┘
```

- **核心模块**：负责 SDK 的初始化、配置管理、生命周期管理
- **数据采集**：包括错误监控、性能监控、用户行为监控等子模块
- **数据处理**：对采集的原始数据进行清洗、过滤、聚合和加工
- **数据上报**：负责将处理后的数据按照一定策略上报到服务端
- **公共工具**：提供通用工具函数、类型定义等

### 1.2 技术选型

- 开发语言：**TypeScript**（类型安全、可维护性强）
- 构建工具：**Rollup**（轻量级、Tree-Shaking、多格式输出）
- 包管理工具：**pnpm**（高效、节省磁盘空间）
- 代码规范：ESLint + Prettier
- 单元测试：Jest
- 文档生成：TypeDoc
- CI/CD：GitHub Actions

### 1.3 输出格式

SDK 将支持多种模块化格式，以适应不同的使用场景：

- ESM（ES Module）：用于支持现代化构建工具和 Tree-Shaking
- UMD（Universal Module Definition）：兼容 CommonJS 和 AMD，可直接通过 CDN 在浏览器使用
- IIFE（立即执行函数）：用于直接在浏览器中通过 script 标签引入

## 2. 核心模块设计

### 2.1 模块结构

SDK 采用微内核+插件化架构，实现高度可定制化：

```
┌───────────────────────────────────────────┐
│               SDK核心                      │
├───────────────────────────────────────────┤
│                事件总线                    │
├──────────┬──────────┬───────────┬─────────┤
│ 错误监控插件│性能监控插件│用户行为插件 │...其他插件│
└──────────┴──────────┴───────────┴─────────┘
```

核心模块负责：

- SDK 初始化和配置
- 插件注册和管理
- 事件总线（发布/订阅模式）
- 公共资源管理

### 2.2 核心 API 设计

```typescript
// 监控SDK配置接口
interface MonitorConfig {
  appId: string; // 应用标识
  userId?: string; // 用户标识(可选)
  reportUrl: string; // 上报接口地址
  reportFrequency?: number; // 上报频率(ms)
  enabledPlugins?: string[]; // 启用的插件列表
  sampling?: number; // 采样率(0-1)

  // 错误监控配置
  errorConfig?: {
    enableJsError?: boolean; // 是否监控JS错误
    enablePromiseError?: boolean; // 是否监控Promise错误
    enableResourceError?: boolean; // 是否监控资源加载错误
    enableHttpError?: boolean; // 是否监控HTTP请求错误
    ignoreErrors?: RegExp[]; // 忽略的错误
  };

  // 性能监控配置
  performanceConfig?: {
    enableVitals?: boolean; // 是否监控性能指标
    enableResource?: boolean; // 是否监控资源加载性能
    enableLongTask?: boolean; // 是否监控长任务
    enableMemory?: boolean; // 是否监控内存使用情况
    enableFirstScreen?: boolean; // 是否监控首屏加载时间
    enableWhiteScreen?: boolean; // 是否监控白屏
  };

  // 用户行为监控配置
  behaviorConfig?: {
    enablePV?: boolean; // 是否监控PV
    enableClick?: boolean; // 是否监控点击事件
    enableScroll?: boolean; // 是否监控滚动事件
    enableRoute?: boolean; // 是否监控路由变化
    maxBehaviorRecords?: number; // 最大行为记录数
  };

  // 录屏配置
  rrwebConfig?: {
    enabled?: boolean; // 是否启用录屏
    recordBeforeError?: number; // 错误发生前记录的时间(秒)
    recordAfterError?: number; // 错误发生后记录的时间(秒)
    maxRecordTime?: number; // 最大录制时长(秒)
  };
}

// SDK主类
class Monitor {
  constructor(config: MonitorConfig);

  // 初始化SDK
  init(): void;

  // 注册插件
  use(plugin: Plugin): Monitor;

  // 手动上报错误
  reportError(error: Error, context?: Record<string, any>): void;

  // 手动上报自定义事件
  reportEvent(name: string, data: Record<string, any>): void;

  // 设置用户信息
  setUser(userId: string, userInfo?: Record<string, any>): void;

  // 设置额外信息
  setExtra(key: string, value: any): void;

  // 启动SDK
  start(): void;

  // 停止SDK
  stop(): void;

  // 销毁SDK实例
  destroy(): void;
}
```

### 2.3 插件系统设计

```typescript
// 插件接口
interface Plugin {
  name: string; // 插件名称
  init(monitor: Monitor): void; // 初始化方法
  destroy?(): void; // 销毁方法
}

// 事件总线接口
interface EventBus {
  on(event: string, callback: Function): void; // 订阅事件
  off(event: string, callback?: Function): void; // 取消订阅
  emit(event: string, ...args: any[]): void; // 发布事件
  once(event: string, callback: Function): void; // 订阅一次性事件
}
```

## 3. 数据采集模块设计

### 3.1 错误监控模块

#### 3.1.1 JS 错误采集

```typescript
// JS错误监控插件
class JsErrorPlugin implements Plugin {
  name: string = 'js-error';

  private handleError = (event: ErrorEvent) => {
    // 处理JS错误
  };

  private handleUnhandledRejection = (event: PromiseRejectionEvent) => {
    // 处理Promise错误
  };

  init(monitor: Monitor): void {
    // 监听JS错误
    window.addEventListener('error', this.handleError);
    // 监听Promise未处理的rejection
    window.addEventListener('unhandledrejection', this.handleUnhandledRejection);
    // ...
  }

  destroy(): void {
    window.removeEventListener('error', this.handleError);
    window.removeEventListener('unhandledrejection', this.handleUnhandledRejection);
    // ...
  }
}
```

#### 3.1.2 资源加载错误

通过事件捕获阶段的 error 事件来监听资源加载错误。

#### 3.1.3 接口错误

通过 AOP（面向切面编程）重写 XMLHttpRequest 和 fetch 方法来监控接口错误。

```typescript
// HTTP请求监控插件
class HttpErrorPlugin implements Plugin {
  name: string = 'http-error';

  init(monitor: Monitor): void {
    this.overrideXHR();
    this.overrideFetch();
  }

  private overrideXHR(): void {
    // 重写XMLHttpRequest
  }

  private overrideFetch(): void {
    // 重写fetch
  }
}
```

#### 3.1.4 框架错误

针对 Vue 和 React 等框架的特定错误处理。

```typescript
// Vue错误监控插件
class VueErrorPlugin implements Plugin {
  name: string = 'vue-error';

  init(monitor: Monitor): void {
    if (window.Vue) {
      window.Vue.config.errorHandler = (error, vm, info) => {
        // 处理Vue错误
      };
    }
  }
}

// React错误监控插件（需要在React组件中使用ErrorBoundary）
```

### 3.2 性能监控模块

#### 3.2.1 Web Vitals 监控

使用 PerformanceObserver API 监控关键性能指标。

```typescript
// Web Vitals监控插件
class WebVitalsPlugin implements Plugin {
  name: string = 'web-vitals';

  init(monitor: Monitor): void {
    this.observeLCP();
    this.observeFID();
    this.observeCLS();
    this.observeFP();
    this.observeFCP();
    // ...
  }

  private observeLCP(): void {
    // 监控LCP
  }

  private observeFID(): void {
    // 监控FID
  }

  // ...
}
```

#### 3.2.2 资源加载性能

监控页面资源加载性能，计算资源缓存率等指标。

```typescript
// 资源加载性能监控插件
class ResourcePerformancePlugin implements Plugin {
  name: string = 'resource-performance';

  init(monitor: Monitor): void {
    this.observeResourceTiming();
  }

  private observeResourceTiming(): void {
    const observer = new PerformanceObserver((list) => {
      const entries = list.getEntries();
      // 处理资源加载性能数据
    });

    observer.observe({ entryTypes: ['resource'] });
  }
}
```

#### 3.2.3 个性化指标

监控 Long Task、内存使用、首屏加载时间、白屏检测等自定义指标。

```typescript
// Long Task监控插件
class LongTaskPlugin implements Plugin {
  name: string = 'long-task';

  init(monitor: Monitor): void {
    this.observeLongTask();
  }

  private observeLongTask(): void {
    const observer = new PerformanceObserver((list) => {
      const entries = list.getEntries();
      // 处理长任务数据
    });

    observer.observe({ entryTypes: ['longtask'] });
  }
}

// 内存监控插件
class MemoryPlugin implements Plugin {
  // ...
}

// 首屏时间监控插件
class FirstScreenPlugin implements Plugin {
  // ...
}

// 白屏检测插件
class WhiteScreenPlugin implements Plugin {
  // ...
}
```

### 3.3 用户行为监控模块

#### 3.3.1 路由跳转记录

```typescript
// 路由监控插件
class RoutePlugin implements Plugin {
  name: string = 'route';

  init(monitor: Monitor): void {
    this.listenRouteChange();
  }

  private listenRouteChange(): void {
    // 监听popstate事件
    window.addEventListener('popstate', this.handlePopState);

    // 重写history方法
    this.overrideHistory();

    // 监听hashchange事件
    window.addEventListener('hashchange', this.handleHashChange);
  }

  // ...
}
```

#### 3.3.2 用户交互行为

```typescript
// 用户点击行为监控插件
class ClickBehaviorPlugin implements Plugin {
  name: string = 'click-behavior';

  init(monitor: Monitor): void {
    // PC端监听
    document.addEventListener('click', this.handleClick);
    // 移动端监听
    document.addEventListener('touchstart', this.handleTouch);
  }

  // ...
}

// 滚动行为监控插件
class ScrollBehaviorPlugin implements Plugin {
  // ...
}
```

#### 3.3.3 PV/UV 统计

```typescript
// PV/UV统计插件
class PvUvPlugin implements Plugin {
  name: string = 'pv-uv';

  init(monitor: Monitor): void {
    // 页面加载完成时触发PV统计
    window.addEventListener('load', this.recordPV);

    // 记录UV
    this.recordUV();
  }

  private recordPV = (): void => {
    // 记录PV逻辑
  };

  private recordUV(): void {
    // 记录UV逻辑
  }
}
```

## 4. 数据上报模块设计

### 4.1 上报方式

```typescript
// 上报接口
interface Reporter {
  send(data: ReportData): Promise<boolean>;
}

// 数据上报类
class DataReporter {
  private reporters: Reporter[] = [];

  constructor(private config: ReporterConfig) {
    this.initReporters();
  }

  private initReporters(): void {
    // 初始化上报方式，按优先级排序
    this.reporters.push(new BeaconReporter(this.config));
    this.reporters.push(new ImageReporter(this.config));
    this.reporters.push(new XhrReporter(this.config));
  }

  async report(data: ReportData): Promise<boolean> {
    // 尝试使用不同上报方式，直到成功
    for (const reporter of this.reporters) {
      try {
        const success = await reporter.send(data);
        if (success) return true;
      } catch (err) {
        // 上报失败，尝试下一种方式
      }
    }

    // 所有上报方式都失败，将数据缓存到本地
    this.cacheData(data);
    return false;
  }

  private cacheData(data: ReportData): void {
    // 缓存数据到localStorage
  }
}

// Beacon上报
class BeaconReporter implements Reporter {
  constructor(private config: ReporterConfig) {}

  send(data: ReportData): Promise<boolean> {
    if (!navigator.sendBeacon) return Promise.resolve(false);

    const success = navigator.sendBeacon(this.config.reportUrl, JSON.stringify(data));

    return Promise.resolve(success);
  }
}

// 图片上报
class ImageReporter implements Reporter {
  // ...
}

// XHR上报
class XhrReporter implements Reporter {
  // ...
}
```

### 4.2 上报策略

```typescript
// 上报策略接口
interface ReportStrategy {
  shouldReport(data: ReportData): boolean;
  process(queue: ReportData[]): ReportData[];
}

// 实时上报策略
class RealTimeStrategy implements ReportStrategy {
  shouldReport(data: ReportData): boolean {
    // 判断是否需要实时上报
    return data.level === 'error' || data.isApiError;
  }

  process(queue: ReportData[]): ReportData[] {
    return queue;
  }
}

// 批量上报策略
class BatchStrategy implements ReportStrategy {
  constructor(private maxBatchSize: number = 10) {}

  shouldReport(data: ReportData): boolean {
    return false; // 由批处理定时器触发上报
  }

  process(queue: ReportData[]): ReportData[] {
    // 压缩、合并相似事件等处理
    return queue.slice(0, this.maxBatchSize);
  }
}

// 上报控制器
class ReportController {
  private queue: ReportData[] = [];
  private timer: number | null = null;
  private strategies: ReportStrategy[] = [];

  constructor(private reporter: DataReporter, private config: ReportConfig) {
    this.initStrategies();
    this.startTimer();
  }

  private initStrategies(): void {
    this.strategies.push(new RealTimeStrategy());
    this.strategies.push(new BatchStrategy(this.config.batchSize));
  }

  add(data: ReportData): void {
    // 采样处理
    if (!this.shouldSample(data)) return;

    // 添加到队列
    this.queue.push(data);

    // 检查是否需要立即上报
    for (const strategy of this.strategies) {
      if (strategy.shouldReport(data)) {
        this.flush();
        break;
      }
    }
  }

  private shouldSample(data: ReportData): boolean {
    // 采样率判断，严重错误100%采集
    if (data.level === 'error') return true;
    return Math.random() < (this.config.sampling || 1);
  }

  flush(): void {
    if (this.queue.length === 0) return;

    // 应用处理策略
    let dataToReport = this.queue;
    for (const strategy of this.strategies) {
      dataToReport = strategy.process(dataToReport);
    }

    // 上报数据
    this.reporter.report(dataToReport);

    // 清空队列
    this.queue = [];
  }

  private startTimer(): void {
    // 定期上报
    this.timer = window.setInterval(() => {
      this.flush();
    }, this.config.reportInterval || 5000);
  }

  beforeUnload(): void {
    // 页面关闭前上报
    this.flush();
  }
}
```

## 5. 错误还原设计

### 5.1 Sourcemap 解析

```typescript
// Sourcemap解析在服务端实现，客户端上报足够的错误信息
interface ErrorReportData extends ReportData {
  stack: string; // 错误堆栈
  filename: string; // 出错文件名
  lineno: number; // 行号
  colno: number; // 列号
  message: string; // 错误信息
  version: string; // 应用版本
}
```

### 5.2 RRWeb 录屏

```typescript
// RRWeb录屏插件
class RRWebPlugin implements Plugin {
  name: string = 'rrweb';
  private events: any[] = [];
  private isRecording: boolean = false;
  private stopRecordingTimer: number | null = null;

  init(monitor: Monitor): void {
    const config = monitor.getConfig().rrwebConfig;
    if (!config?.enabled) return;

    this.startRecording();

    // 监听错误事件，错误发生时保存录屏
    monitor.on('error', this.handleError);
  }

  private startRecording(): void {
    this.isRecording = true;

    // 初始化rrweb
    rrweb.record({
      emit: (event) => {
        // 保存录屏事件
        this.events.push(event);

        // 控制录屏数量，避免内存过大
        if (this.events.length > 1000) {
          this.events.shift();
        }
      },
    });
  }

  private handleError = (error: any): void => {
    // 错误发生时，继续录制一段时间后停止
    if (this.stopRecordingTimer) {
      clearTimeout(this.stopRecordingTimer);
    }

    const config = monitor.getConfig().rrwebConfig;

    // 错误发生后继续录制一段时间
    this.stopRecordingTimer = setTimeout(() => {
      this.stopRecording();
      this.reportRecording(error);
    }, (config?.recordAfterError || 5) * 1000);
  };

  private stopRecording(): void {
    this.isRecording = false;
    // 停止录制
  }

  private reportRecording(error: any): void {
    // 上报录屏数据
    monitor.reportEvent('rrweb', {
      events: this.events,
      errorInfo: error,
    });

    // 清空录屏数据
    this.events = [];
  }
}
```

### 5.3 用户行为栈

```typescript
// 用户行为栈插件
class UserBehaviorStackPlugin implements Plugin {
  name: string = 'behavior-stack';
  private stack: BehaviorRecord[] = [];
  private maxStackSize: number = 50;

  init(monitor: Monitor): void {
    const config = monitor.getConfig().behaviorConfig;
    if (config?.maxBehaviorRecords) {
      this.maxStackSize = config.maxBehaviorRecords;
    }

    // 监听各种用户行为事件
    monitor.on('click', this.recordBehavior);
    monitor.on('route', this.recordBehavior);
    monitor.on('api', this.recordBehavior);

    // 监听错误，错误发生时上报行为栈
    monitor.on('error', this.handleError);
  }

  private recordBehavior = (data: any): void => {
    // 记录行为到栈中
    this.stack.push({
      type: data.type,
      time: Date.now(),
      data: data.data,
    });

    // 控制栈大小
    if (this.stack.length > this.maxStackSize) {
      this.stack.shift();
    }
  };

  private handleError = (error: any): void => {
    // 错误发生时，上报用户行为栈
    monitor.reportEvent('behavior-stack', {
      stack: this.stack,
      errorInfo: error,
    });
  };
}
```

## 6. 应用接入方式

### 6.1 基本使用

```typescript
// NPM包引入方式
import { Monitor } from 'fe-monitor-sdk';

// 初始化SDK
const monitor = new Monitor({
  appId: 'your-app-id',
  reportUrl: 'https://report.example.com/collect',
  sampling: 0.5, // 采样率50%

  // 错误监控配置
  errorConfig: {
    enableJsError: true,
    enablePromiseError: true,
    enableResourceError: true,
    enableHttpError: true,
  },

  // 性能监控配置
  performanceConfig: {
    enableVitals: true,
    enableResource: true,
  },

  // 用户行为监控配置
  behaviorConfig: {
    enablePV: true,
    enableClick: true,
    enableRoute: true,
  },

  // 录屏配置
  rrwebConfig: {
    enabled: true,
    recordBeforeError: 5,
    recordAfterError: 5,
  },
});

// 启动监控
monitor.start();

// 手动上报错误
try {
  // 危险操作
} catch (err) {
  monitor.reportError(err, {
    // 额外信息
    page: 'home',
    action: 'click-button',
  });
}

// 设置用户信息
monitor.setUser('user-123', {
  level: 'vip',
  region: 'cn',
});
```

### 6.2 CDN 引入方式

```html
<script src="https://cdn.example.com/fe-monitor-sdk.min.js"></script>
<script>
  window.Monitor.init({
    appId: 'your-app-id',
    reportUrl: 'https://report.example.com/collect',
    // 其他配置...
  });
</script>
```

## 7. 构建与部署流程

### 7.1 开发环境搭建

```bash
# 安装依赖
pnpm install

# 开发模式
pnpm dev

# 构建
pnpm build

# 测试
pnpm test

# 文档生成
pnpm docs
```

### 7.2 目录结构

```
fe-monitor-sdk/
├── src/
│   ├── core/          # 核心模块
│   ├── plugins/       # 插件目录
│   │   ├── error/     # 错误监控插件
│   │   ├── performance/ # 性能监控插件
│   │   ├── behavior/  # 行为监控插件
│   │   └── rrweb/     # 录屏插件
│   ├── transport/     # 数据上报模块
│   ├── utils/         # 工具函数
│   └── index.ts       # 入口文件
├── tests/             # 测试目录
├── docs/              # 文档
├── examples/          # 示例
├── rollup.config.js   # rollup配置
├── tsconfig.json      # TypeScript配置
├── package.json       # 项目配置
└── README.md          # 项目说明
```

### 7.3 构建配置

```javascript
// rollup.config.js
import typescript from 'rollup-plugin-typescript2';
import { terser } from 'rollup-plugin-terser';
import commonjs from '@rollup/plugin-commonjs';
import resolve from '@rollup/plugin-node-resolve';
import dts from 'rollup-plugin-dts';

export default [
  // ESM, UMD, IIFE 三种格式
  {
    input: 'src/index.ts',
    output: [
      {
        file: 'dist/index.esm.js',
        format: 'esm',
      },
      {
        file: 'dist/index.umd.js',
        format: 'umd',
        name: 'Monitor',
      },
      {
        file: 'dist/index.iife.js',
        format: 'iife',
        name: 'Monitor',
      },
    ],
    plugins: [
      typescript({
        tsconfig: './tsconfig.json',
      }),
      resolve(),
      commonjs(),
      terser(),
    ],
  },
  // 类型定义
  {
    input: 'src/index.ts',
    output: {
      file: 'dist/index.d.ts',
      format: 'es',
    },
    plugins: [dts()],
  },
];
```

## 8. 项目规划与迭代

### 8.1 第一阶段（基础功能）

- 核心框架搭建
- 基础错误监控（JS 错误、Promise 错误、资源错误）
- 基础性能监控（FP、FCP、LCP）
- 简单数据上报功能

### 8.2 第二阶段（增强功能）

- HTTP 请求监控
- 框架错误监控（Vue、React）
- 高级性能指标监控（FID、CLS、TTI 等）
- 用户行为监控
- PV/UV 统计

### 8.3 第三阶段（高级功能）

- RRWeb 录屏功能
- 用户行为栈
- 白屏检测
- Long Task 监控
- 首屏时间监控

### 8.4 第四阶段（优化与完善）

- 性能优化
- 兼容性测试与完善
- 文档完善
- 接入示例开发

## 9. 总结

本概要设计基于需求文档，详细设计了一个基于 TypeScript、Rollup 和 pnpm 的前端监控 SDK，采用插件化架构，具有良好的扩展性和可维护性。通过模块化设计，可以根据需要灵活配置和使用不同的监控功能。该 SDK 覆盖了错误监控、性能监控、用户行为监控等核心功能，并提供了错误还原、数据上报等关键特性。
